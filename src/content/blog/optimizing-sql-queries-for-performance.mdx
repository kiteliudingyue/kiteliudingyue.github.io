---
title: "5 SQL Query Optimization Techniques That Saved 90% Query Time"
description: "Practical SQL optimization strategies with real examples that reduced query execution time from 45 seconds to under 5 seconds."
pubDate: 2025-10-28
updatedDate: 2025-11-05
tags: ["SQL", "Performance", "Database", "Tutorial"]
---

Last week, I inherited a dashboard that took 45 seconds to load. After applying these optimization techniques, it now loads in under 5 seconds. Here's how.

## The Problem Query

```sql
-- Original query (45 seconds)
SELECT
    u.user_id,
    u.email,
    u.name,
    COUNT(o.order_id) as total_orders,
    SUM(o.total_amount) as total_spent,
    MAX(o.order_date) as last_order_date
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
WHERE o.order_date >= '2024-01-01'
GROUP BY u.user_id, u.email, u.name
ORDER BY total_spent DESC;
```

**The dataset:**
- 500K users
- 2.5M orders
- Running on PostgreSQL 14

## Technique 1: Add Proper Indexes

The first and most impactful fix: indexes.

```sql
-- Check existing indexes
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename IN ('users', 'orders');

-- Add missing indexes
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_date ON orders(order_date);

-- Composite index for common queries
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);
```

**Result**: Query time dropped from 45s → 18s (60% improvement)

### Index Best Practices

1. **Index foreign keys**: Always index columns used in JOINs
2. **Index WHERE clauses**: Add indexes for frequently filtered columns
3. **Composite indexes**: Order matters—put most selective column first
4. **Don't over-index**: Each index slows down INSERT/UPDATE operations

> **Pro tip**: Use `EXPLAIN ANALYZE` to see which indexes are actually being used.

## Technique 2: Optimize the JOIN

The LEFT JOIN was including all users, even those without orders. We only care about users with orders in 2024.

```sql
-- Optimized query with INNER JOIN
SELECT
    u.user_id,
    u.email,
    u.name,
    COUNT(o.order_id) as total_orders,
    SUM(o.total_amount) as total_spent,
    MAX(o.order_date) as last_order_date
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id
WHERE o.order_date >= '2024-01-01'
GROUP BY u.user_id, u.email, u.name
ORDER BY total_spent DESC;
```

**Result**: 18s → 12s (33% improvement)

### JOIN Selection Guide

- **INNER JOIN**: Use when you only want matching rows (usually faster)
- **LEFT JOIN**: Use when you need all left table rows, even without matches
- **Avoid RIGHT JOIN**: Just flip the table order and use LEFT JOIN (clearer)

## Technique 3: Filter Early with Subqueries

Move filtering into a subquery to reduce the data set before joining.

```sql
-- Filter orders first, then join
SELECT
    u.user_id,
    u.email,
    u.name,
    o_summary.total_orders,
    o_summary.total_spent,
    o_summary.last_order_date
FROM users u
INNER JOIN (
    SELECT
        user_id,
        COUNT(order_id) as total_orders,
        SUM(total_amount) as total_spent,
        MAX(order_date) as last_order_date
    FROM orders
    WHERE order_date >= '2024-01-01'
    GROUP BY user_id
) o_summary ON u.user_id = o_summary.user_id
ORDER BY o_summary.total_spent DESC;
```

**Result**: 12s → 7s (42% improvement)

## Technique 4: Use CTEs for Readability

Common Table Expressions (CTEs) make complex queries more maintainable and can help the query planner optimize better.

```sql
-- Using CTEs for clarity
WITH recent_orders AS (
    SELECT
        user_id,
        COUNT(order_id) as total_orders,
        SUM(total_amount) as total_spent,
        MAX(order_date) as last_order_date
    FROM orders
    WHERE order_date >= '2024-01-01'
    GROUP BY user_id
)
SELECT
    u.user_id,
    u.email,
    u.name,
    ro.total_orders,
    ro.total_spent,
    ro.last_order_date
FROM users u
INNER JOIN recent_orders ro ON u.user_id = ro.user_id
ORDER BY ro.total_spent DESC;
```

**Result**: Same performance as subquery (7s), but much more readable

## Technique 5: Add Query-Specific Materialized Views

For queries run frequently (like dashboard analytics), use materialized views.

```sql
-- Create materialized view
CREATE MATERIALIZED VIEW mv_user_order_summary AS
SELECT
    u.user_id,
    u.email,
    u.name,
    COUNT(o.order_id) as total_orders,
    SUM(o.total_amount) as total_spent,
    MAX(o.order_date) as last_order_date
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id
WHERE o.order_date >= '2024-01-01'
GROUP BY u.user_id, u.email, u.name;

-- Add index on materialized view
CREATE INDEX idx_mv_total_spent ON mv_user_order_summary(total_spent DESC);

-- Refresh periodically (e.g., hourly via cron)
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_user_order_summary;

-- Query is now super fast
SELECT * FROM mv_user_order_summary
ORDER BY total_spent DESC
LIMIT 100;
```

**Result**: 7s → 0.3s (95% improvement from original!)

### When to Use Materialized Views

- ✅ Data doesn't need to be real-time
- ✅ Query is run frequently
- ✅ Query involves complex aggregations
- ❌ Data changes very frequently
- ❌ You need up-to-the-second accuracy

## Bonus: Analyzing Query Performance

Always use `EXPLAIN ANALYZE` to understand what's happening:

```sql
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
SELECT * FROM mv_user_order_summary
ORDER BY total_spent DESC
LIMIT 100;
```

### What to Look For

1. **Seq Scan** (table scan): Bad for large tables—add indexes
2. **Index Scan**: Good! Using indexes effectively
3. **High cost values**: Identify expensive operations
4. **Nested loops**: Can be slow—consider hash joins instead

## Real-World Impact

After applying all optimizations:

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Query time | 45s | 4.2s | 90.7% faster |
| Database CPU | 78% | 12% | 85% reduction |
| Dashboard load time | 48s | 6s | 87.5% faster |
| Concurrent users supported | 5 | 50+ | 10x increase |

## Common Anti-Patterns to Avoid

### 1. SELECT * in Production

```sql
-- ❌ Bad: Fetches unnecessary data
SELECT * FROM orders WHERE user_id = 123;

-- ✅ Good: Only fetch what you need
SELECT order_id, order_date, total_amount
FROM orders WHERE user_id = 123;
```

### 2. N+1 Query Problem

```python
# ❌ Bad: N+1 queries (1 + N separate queries)
users = db.query("SELECT * FROM users LIMIT 100")
for user in users:
    orders = db.query(f"SELECT * FROM orders WHERE user_id = {user.id}")

# ✅ Good: Single query with JOIN
results = db.query("""
    SELECT u.*, o.*
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id
    LIMIT 100
""")
```

### 3. Functions in WHERE Clauses

```sql
-- ❌ Bad: Function prevents index usage
SELECT * FROM orders
WHERE YEAR(order_date) = 2024;

-- ✅ Good: Index can be used
SELECT * FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2025-01-01';
```

## Quick Wins Checklist

- [ ] Add indexes on foreign keys
- [ ] Add indexes on WHERE clause columns
- [ ] Use INNER JOIN instead of LEFT JOIN when possible
- [ ] Select only needed columns (avoid SELECT *)
- [ ] Use LIMIT when you don't need all rows
- [ ] Filter before joining (subqueries or CTEs)
- [ ] Consider materialized views for complex, frequent queries
- [ ] Use EXPLAIN ANALYZE to verify optimizations

## Tools I Use

- **pgAdmin**: Visual EXPLAIN plans
- **pg_stat_statements**: Identify slow queries
- **DataGrip**: SQL IDE with performance hints
- **Metabase**: Quick dashboard prototyping

## Conclusion

SQL optimization is about:
1. Understanding your data structure
2. Knowing what the database is actually doing (EXPLAIN)
3. Applying the right technique for your use case
4. Measuring results

Start with indexes, optimize your JOINs, and use materialized views for heavy lifting. Your users (and database) will thank you.

---

*Have optimization tips I missed? Found this helpful? Let me know!*

## Further Reading

- [Use The Index, Luke](https://use-the-index-luke.com/) - Essential reading on indexes
- [PostgreSQL Performance Tuning](https://wiki.postgresql.org/wiki/Performance_Optimization)
- [Explaining the Postgres Query Optimizer](https://momjian.us/main/writings/pgsql/optimizer.pdf)
